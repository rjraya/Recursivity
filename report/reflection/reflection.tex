\subsection{La esencia de la computación}

¿Cuál es la esencia de la computación? En la actividad que se desarrolla en un facultad de informática, parece que lo fundamental es el \textit{dato} y la transformación que ocurre sobre este dato. De aquí surgen dos preguntas naturales:

\begin{itemize}
	\item ¿Qué datos son admisibles?
	\item ¿Qué transformaciones son admisibles?
\end{itemize}

La respuesta a esta pregunta ha llevado al desarrollo de modelos: el lambda-cálculo, las máquinas de Turing y la teoría de la recursión, que han sido demostrados equivalentes. De aquí, la tesis de Church y Turing que establecería que cualquier modelo que representa lo que los humanos podemos calcular mediante procedimientos mecánicos tendría un poder equivalente al de estas teorías. 

Así que la práctica en la computación consiste en reducir aquellos problemas a algunos de estos lenguajes. Así, la lógica puede ser codificada en términos de funciones recursivas, una metodología empleada por Göedel en la prueba del teorema de incompletitud. Y en la teoría de la (meta)programación se reducen los objetos a elementos del lambda cálculo. De modo que, podríamos convenir que las implementaciones que existen en nuestros días son fieles a esta forma de trabajo y no pueden superarla. 

Nuestro tema de estudio es precisamente es precisamente una de esas cuestiones que muestran las limitaciones de estos modelos. No puede describirse una transformación en este modelo, que dado un conjunto de transformaciones secuenciales escrito en forma finita permita determinar si este conjunto de transformaciones puede ser interpretado en tiempo finito. No está demás dar una intuición de por qué esto es así:

Sea $f$ una tal transformación y sea \[g(i) = f((g,i)); \text{ if(yes) don't terminate else terminate}\] está transformación hará justamente lo contrario de lo que prediga $f$. Lógicamente, esta explicación require especificar los datos y las transformaciones admisibles según el sentido anterior. Ahora bien, la indecibilidad del problema de la parada solo informa la incapacidad de un sólo algoritmo para exhauscir el espacio de los programas terminantes. Surgen entonces algunas preguntas:

\begin{itemize}
	\item ¿podría existir una clase de algoritmos que exhausciera el espacio de los programas terminantes? Ciertamente, esta clase no podría ser finita pues entonces podríamos probar cada algoritmo en paralelo. ¿Existe algún cardinal de algoritmos que lo permitiera?
	\item ¿Hay algún problema cuya terminación es indecidible?
\end{itemize}

De estas reflexiones llegamos al punto inicial de nuestra investigación: la clasificación de los problemas terminantes y no terminantes. Aquí podemos utilizar cualquier técnica de la matemática moderna para llevar a cabo dicha clasificación. Para ello hay que encontrar \textit{codificaciones} adecuadas así como valernos del conocimiento experto en cada área.

Veamos entonces, qué elementos habría que pensar aquí. Respecto a las codificaciones:

\begin{itemize}
	\item ¿Cambia algo el hecho de que el número de transformaciones sea 1, finito o un número ilimitado de transformaciones?
	
	\item en el espíritu de la lógica es natural reducir problemas mecánicos a problemas numéricos. Este es el enfoque de Göedel pero también de Turing en su tesis de doctorado donde muestra como los problemas numéricos y los computacionales guardan una estrecha relación. Este es el enfoque por ejemplo del size-change termination.
	
	\item Existen otras codificaciones como los sistemas de reescritura de términos. 
\end{itemize}

Respecto a las herramientas para la clasificación:

\begin{itemize}
	\item teorías matemáticas que separan objetos como la topología que separa en abiertos y cuya base son los conjuntos por el simple hecho de que la matemática de aquel tiempo se basaba en la teoría de conjuntos.
	
	\item problemas de clasificación son habituales en machine learning. Otras técnicas probabilistas podrían ser de uso, haciendo sampling del algoritmo con distintos parámetros podría verse su trayectoria en un cierto ordinal (piénsese la trayectoria en $\mathbb{N} \times \mathbb{N}$).
\end{itemize}

Respecto a las aplicaciones. Nos planteamos si un intérprete podría no terminar cuando se ejecuta a sí mismo. También nos preguntamos qué diferencia existe entre lo que se puede calcular y lo que es cierto, esto es, la lógica constructiva. 

\subsection{La clave no es el resultado sino cómo se calcula el resultado}


En la teoría de la recursividad lo importante no es la funciones que se pueden calcular, sino cómo se pueden calcular. Esto es ya visto en la base, ciertos tipos de funciones básicas se pueden calcular mientras que otras funciones se obtienen combinando estas mediante ciertos combinadores. Esto es precisamente lo que limita el poder de lo que se puede expresar en un computador. Esto es la esencia de la ciencia de los compiladores, lo importante no es lo que se escribe sino cómo se ejecuta lo que se escribe. 

En nuestro trabajo utilizaremos dos formalismos: el lambda-cálculo y teoría de la recursividad. No está claro aún cuál es el papel de las medidas sobre la terminación de programas. 

\begin{itemize}
\item ¿es posible quedarse con una sola función para analizar la terminación? sí.

Si $f,g$ son funciones mutuamente recursivas podemos poner $h(w) = if(w = 1) then código de f else código de g$ donde se ha hecho $unfold(f)[f \mapsto h(1), g \mapsto h(0)]$.

\item podemos expresar el procesador de relaciones y el procesador de cadenas como transformaciones de programas

\item ¿podríamos reducir el número de parámetros de las funciones de Gö
\end{itemize}






















